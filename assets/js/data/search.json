[ { "title": "Tech Talk 3 Notes &amp; Code", "url": "/CSA-Data-Structures/posts/tt3/", "categories": "", "tags": "techtalks", "date": "2022-03-28 00:00:00 +0000", "snippet": "Bubble SortBubble sort moves through a list of elements, checking whether an element is larger than the next, if so swap the two. This will cause large elements to bubble to the back, and small elements slowly move to the front. Eventually, after this process is done enough time the list will be sorted.Statistics:Average Bubble Sort Time: 173.4375msAverage Bubble Sort Comparisons: 1.24975E7Average Bubble Sort Swaps: 6236010.6875Big-O Complexity: O(N^2)Code:public static &amp;lt;T extends Comparable&amp;lt;T&amp;gt;&amp;gt; Tuple&amp;lt;Integer, Integer&amp;gt; bubbleSort(ArrayList&amp;lt;T&amp;gt; list) { int comparisons = 0; int swaps = 0; for (int i = 0; i &amp;lt; list.size() - 1; i++) { for (int j = 0; j &amp;lt; list.size() - 1 - i; j++) { if (list.get(j).compareTo(list.get(j + 1)) &amp;gt; 0) { T temp = list.get(j); list.set(j, list.get(j + 1)); list.set(j + 1, temp); swaps++; } comparisons++; } } return new Tuple&amp;lt;&amp;gt;(comparisons, swaps);}Selection Sort:Selection sort splits a list into a subarray which is sorted, and another which is not. It begins with the entire array being unsorted, and moves the smallest element to the front. Now the first element belongs to the subarray which is sorted, and we remove it from the unsorted subarray and repeat. Once we’ve moved through the whole array the list will be sorted.Statistics:Average Selection Sort Time: 45.3125msAverage Selection Sort Comparisons: 1.24975E7Average Selection Sort Swaps: 4999.0Big-O Complexity: O(N^2)Code:public static &amp;lt;T extends Comparable&amp;lt;T&amp;gt;&amp;gt; Tuple&amp;lt;Integer, Integer&amp;gt; selectionSort(ArrayList&amp;lt;T&amp;gt; list) { int comparisons = 0; int swaps = 0; for (int i = 0; i &amp;lt; list.size() - 1; i++) { int min = i; for (int j = i + 1; j &amp;lt; list.size(); j++) { if (list.get(j).compareTo(list.get(min)) &amp;lt; 0) { min = j; } comparisons++; } T temp = list.get(i); list.set(i, list.get(min)); list.set(min, temp); swaps++; } return new Tuple&amp;lt;&amp;gt;(comparisons, swaps);}Insertion Sort:Insertion sort takes an element, and compares it with every element before it until it finds the position at which it is smaller than the next element but larger than the previous element and inserts it there. This is done for every element in the list, and at the end the list will be sorted.Statistics:Average Insertion Sort Time: 48.9375msAverage Insertion Sort Comparisons: 6247429.1875Average Insertion Sort Swaps: 6252428.1875Big-O Complexity: O(N^2)Code:public static &amp;lt;T extends Comparable&amp;lt;T&amp;gt;&amp;gt; Tuple&amp;lt;Integer, Integer&amp;gt; insertionSort(ArrayList&amp;lt;T&amp;gt; list) { int comparisons = 0; int swaps = 0; for (int i = 1; i &amp;lt; list.size(); i++) { T temp = list.get(i); int j = i; while (j &amp;gt; 0 &amp;amp;&amp;amp; temp.compareTo(list.get(j - 1)) &amp;lt; 0) { list.set(j, list.get(j - 1)); j--; comparisons++; swaps++; } list.set(j, temp); swaps++; } return new Tuple&amp;lt;&amp;gt;(comparisons, swaps);}Merge Sort:Merge sort takes a divide and conquer strategy, splitting a list into half repeatedly until a list has been split into the smallest pieces possible. Then we proceed to recursively merge these subarrays into an order array, by using a two pointer method where we compare the top of two subarrays and add which ever element is smaller, and increment that subarray. At the end of the recursive tree, we now have a merged sorted list.Statistics:Average Merge Sort Time: 50.5625msAverage Merge Sort Comparisons: 5000.0Average Merge Sort Swaps: 5000.0Big-O Complexity: O(N log(N))Code:public static &amp;lt;T extends Comparable&amp;lt;T&amp;gt;&amp;gt; Tuple&amp;lt;Integer, Integer&amp;gt; mergeSort(ArrayList&amp;lt;T&amp;gt; list) { int comparisons = 0; int swaps = 0; if (list.size() &amp;gt; 1) { ArrayList&amp;lt;T&amp;gt; left = new ArrayList&amp;lt;T&amp;gt;(); ArrayList&amp;lt;T&amp;gt; right = new ArrayList&amp;lt;T&amp;gt;(); for (int i = 0; i &amp;lt; list.size() / 2; i++) { left.add(list.get(i)); } for (int i = list.size() / 2; i &amp;lt; list.size(); i++) { right.add(list.get(i)); } mergeSort(left); mergeSort(right); Tuple&amp;lt;Integer, Integer&amp;gt; stats = merge(left, right, list); comparisons += stats.x; swaps += stats.y; } return new Tuple&amp;lt;&amp;gt;(comparisons, swaps);}private static &amp;lt;T extends Comparable&amp;lt;T&amp;gt;&amp;gt; Tuple&amp;lt;Integer, Integer&amp;gt; merge(ArrayList&amp;lt;T&amp;gt; left, ArrayList&amp;lt;T&amp;gt; right, ArrayList&amp;lt;T&amp;gt; list) { int i = 0, j = 0, k = 0; int comparisons = 0; int swaps = 0; while (i &amp;lt; left.size() &amp;amp;&amp;amp; j &amp;lt; right.size()) { if (left.get(i).compareTo(right.get(j)) &amp;lt; 0) { list.set(k, left.get(i)); i++; swaps++; } else { list.set(k, right.get(j)); j++; swaps++; } comparisons++; k++; } while (i &amp;lt; left.size()) { list.set(k, left.get(i)); i++; k++; comparisons++; swaps++; } while (j &amp;lt; right.size()) { list.set(k, right.get(j)); j++; k++; comparisons++; swaps++; } return new Tuple&amp;lt;&amp;gt;(comparisons, swaps);}Conclusion:After examining all 4 methods of sorting, Merge Sort is the best because it has the smallest Big-O Time Complexity, a 3-way tie in terms of average time, and the smallest amount of swaps and comparisons." }, { "title": "PBL Presentation Feedback Notes", "url": "/CSA-Data-Structures/posts/pbl/", "categories": "", "tags": "feedback", "date": "2022-03-25 00:00:00 +0000", "snippet": "Notable Feedback Frontend needs more work, navigation and page organization/worflow. Need some kind of frontend tool to display data, what tool/library? Project can be expanded beyond just the scopes of neuroscience.Plan of Action Frontend planning needed, Figma will be our choice of wireframing. Figma wireframe mockup for Navbar Figma wireframe mockup for Homepage Figma wireframe mockup for Data Upload Page Figma wireframe mockup for Data Analysis Page Frontend workflow/navigation flow needs work, currently unclear how everything is linked, will investigate. Plan out backend infrastructure, aws, s3 buckets, pricing/payment? Find good tool for displaying CSV graphics on frontend, charts.js?" }, { "title": "Tech Talk 2 Notes &amp; Code", "url": "/CSA-Data-Structures/posts/tt2/", "categories": "", "tags": "techtalks", "date": "2022-03-24 00:00:00 +0000", "snippet": "Reverse Polish Notation In mathematics, an expression or mathematical expression is a finite combination of symbols that is well-formed according to rules that depend on the context. In computers, expression can be hard to calculate with precedence rules. In computer math we often convert strings into Reverse Polish Notation (RPN, 3 + 4 becomes 3 4 +) using the Shunting-yard algorithm. RPN involves using a Stack, which aligns with CSA Tri-3’s content as well as CollegeBoard’s material.Replit Runtime + Github Repo: Code PageChallenge - Implement Reverse Polish Notationprivate void tokensToReversePolishNotation() { this.reverse_polish = new ArrayList&amp;lt;&amp;gt;(); Stack&amp;lt;String&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); for (String token : this.tokens) { if (isOperator(token) || isFunction(token)) { while (!stack.empty() &amp;amp;&amp;amp; (isOperator(stack.peek()) || isFunction(stack.peek()))) { if (isPrecedent(token, stack.peek())) { reverse_polish.add(stack.pop()); } else { break; } } stack.push(token); } else if (isSeperator(token)) { if (token.equals(&quot;(&quot;)) { stack.push(token); } else if (token.equals(&quot;)&quot;)) { while (!stack.empty() &amp;amp;&amp;amp; !stack.peek().equals(&quot;(&quot;)) { reverse_polish.add(stack.pop()); } stack.pop(); } } else { reverse_polish.add(token); } } while (!stack.empty()) { reverse_polish.add(stack.pop()); }}private void rpnToResult() { Stack&amp;lt;Double&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); for (String token : reverse_polish) { if (isOperator(token)) { Double operand2 = stack.pop(); Double operand1 = stack.pop(); Double result = 0.0; switch (token) { case &quot;+&quot;: result = operand1 + operand2; break; case &quot;-&quot;: result = operand1 - operand2; break; case &quot;*&quot;: result = operand1 * operand2; break; case &quot;/&quot;: result = operand1 / operand2; break; case &quot;%&quot;: result = operand1 % operand2; break; case &quot;^&quot;: result = Math.pow(operand1, operand2); break; } stack.push(result); } else if (isFunction(token)) { Double operand = stack.pop(); Double result = 0.0; switch (token) { case &quot;SQRT&quot;: result = Math.sqrt(operand); break; } stack.push(result); } else { stack.push(Double.parseDouble(token)); } } this.result = stack.pop();}" }, { "title": "Tech Talk 1 Notes &amp; Code", "url": "/CSA-Data-Structures/posts/tt1/", "categories": "", "tags": "techtalks", "date": "2022-03-18 00:00:00 +0000", "snippet": "Linked Lists Linked Lists is just a list of nodes connected to each other with pointers. Each node has a head and tail which points to the previous and next node. Linked Lists can be used to create Queues and Stacks.Replit Runtime + Github Repo: Code PageChallenge 1 - Add/Delete from Queuepublic void add(T data) { LinkedList&amp;lt;T&amp;gt; tail = new LinkedList&amp;lt;&amp;gt;(data, null); if (head == null) this.head = this.tail = tail; else { this.tail.setNextNode(tail); this.tail = tail; } size++; System.out.println(&quot;Enqueued data: &quot; + data); System.out.print(&quot;Words count: &quot; + this.size + &quot;, data: &quot;); for (T t : this) { System.out.print(t + &quot; &quot;); } System.out.println();}public void delete() { if (head == null) { System.out.println(&quot;Queue is empty&quot;); return; } System.out.println(&quot;Dequeued data: &quot; + head.getData()); head = head.getNext(); size--; System.out.print(&quot;Words count: &quot; + this.size + &quot;, data: &quot;); for (T t : this) { System.out.print(t + &quot; &quot;); } System.out.println();}Challenge 2 - Merge QueuesQueue&amp;lt;Integer&amp;gt; sortedQueue = new Queue&amp;lt;&amp;gt;();while (true) { if (q.getHead() != null &amp;amp;&amp;amp; q2.getHead() != null) { int a = q.getHead().getData(); int b = q2.getHead().getData(); if (a &amp;lt; b) { sortedQueue.add(a); q.delete(); } else { sortedQueue.add(b); q2.delete(); } } else { while (q.getHead() != null) { sortedQueue.add(q.getHead().getData()); q.delete(); } while (q2.getHead() != null) { sortedQueue.add(q2.getHead().getData()); q2.delete(); } break; }}System.out.print(&quot;Sorted Queue: &quot;);for (int i : sortedQueue) { System.out.print(i + &quot; &quot;);}System.out.println();Challenge 3 - Stack from Queuepublic class Stack&amp;lt;T&amp;gt;{ private LinkedList&amp;lt;T&amp;gt; lifo; public Stack() { lifo = null; } public Object peek() { if (lifo == null) return null; else return lifo.getData(); } public void push(T value) { lifo = new LinkedList&amp;lt;&amp;gt;(value, lifo); } public Object pop() { Object value = null; if (lifo != null) { value = lifo.getData(); lifo = lifo.getPrevious(); } return value; } public String toString() { StringBuilder stackToString = new StringBuilder(&quot;[&quot;); LinkedList&amp;lt;T&amp;gt; node = lifo; // start from the back while (node != null) { stackToString.append(node.getData()); // append the database to output string node = node.getPrevious(); // go to previous node if (node != null) stackToString.append(&quot;, &quot;); } // loop &#39;till you reach the beginning stackToString.append(&quot;]&quot;); return stackToString.toString(); }}Queue&amp;lt;Integer&amp;gt; q = new Queue&amp;lt;&amp;gt;();q.add(1);q.add(2);q.add(3);Stack&amp;lt;Integer&amp;gt; s = new Stack&amp;lt;&amp;gt;();for (Integer i : q) { s.push(i);}System.out.println(s);" }, { "title": "Tech Talk 0 Notes &amp; Code", "url": "/CSA-Data-Structures/posts/tt0/", "categories": "", "tags": "techtalks", "date": "2022-03-10 00:00:00 +0000", "snippet": "Intro A data structure is a method of organizing data. Think of algorithms as dynamic underlying pieces that interact with data structures. Together, data structures and algorithms combine and allow programmers to build whatever computer programs they’d like.Programming Paradigms Imperative Paradigm A programming paradigm that uses statements that change a program’s state. Consists of a list of commands that describe how the program operates. Object Oriented Paradigm A programming paradigm that relies on the concept of classes and objects. Used to structure a software program into simple, reusable pieces of code blueprints Basic Data Structures: Arrays Linear data structure in which data is stored one after another. Iteration. Hash Maps Non-Linear data structure in which data is associated with a key when stored. Replit Runtime + Github Repo: Code PageChallenge 1 - Menupublic static void menu() { int selection = 0; Scanner scan = new Scanner(System.in); print_menu(); try { selection = scan.nextInt(); clear(); if (selection == 0) { scan.close(); System.exit(0); } else if (prompts.containsKey(selection)) { prompts.get(selection).run(prompts); } else { System.out.println(&quot;Invalid choice.&quot;); } } catch (Exception e) { clear(); System.out.println(&quot;Invalid choice.&quot;); scan.nextLine(); } menu();}Challenge 2 - Int Referencepublic void swapToLowHighOrder() { if (this.value &amp;gt; this.value2) { this.value = this.value - this.value2; this.value2 = this.value + this.value2; this.value = this.value2 - this.value; }}Challenge 3 - Matrixpublic String toString() { StringBuilder sb = new StringBuilder(); for (int i = 0; i &amp;lt; matrix.length; i++) { for (int j = 0; j &amp;lt; matrix[i].length; j++) { if (matrix[i][j] == -1) { sb.append(&quot; &quot;); } else { sb.append(matrix[i][j] + &quot; &quot;); } } sb.append(&quot;\\n&quot;); } sb.append(&quot;\\n&quot;); for (int i = matrix.length - 1; i &amp;gt;= 0; i--) { for (int j = matrix[i].length - 1; j &amp;gt;= 0; j--) { if (matrix[i][j] == -1) { sb.append(&quot; &quot;); } else { sb.append(matrix[i][j] + &quot; &quot;); } } sb.append(&quot;\\n&quot;); } return sb.toString();}" } ]
